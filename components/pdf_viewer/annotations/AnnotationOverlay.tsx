'use client';

import React, { useState, useRef, useEffect } from 'react';
import { cn } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';
import { useAnnotations } from '@/components/context_panel/annotations/AnnotationProvider';
import { 
  Lightbulb, 
  BookMarked, 
  FileText, 
  Highlighter, 
  MessageSquare,
  PenTool,
  ExternalLink
} from 'lucide-react';
import { BoundingBox as AllenBoundingBox, computeBoundingBoxStyle, Overlay as AllenOverlay } from 'davidkric-pdf-components';

// Enhanced Annotation type enum with more specific types
export enum AnnotationType {
  HIGHLIGHT = 'highlight',
  NOTE = 'note',
  DRAW = 'draw',
  COMMENT = 'comment',
  KEY_INSIGHT = 'key_insight',  // For automatic key sentence detection
  DEFINITION = 'definition',     // For automatic definition detection
  REFERENCE = 'reference',       // For citations/references
  METHOD = 'method',            // For methodology descriptions
  RESULT = 'result',            // For research results
  GOAL = 'goal'                 // For research goals/objectives
}

// Type definitions for annotations
export interface Annotation {
  id: string;
  pageNumber: number;
  boundingRect: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  content: string;
  type: AnnotationType | string;
  color?: string;
  createdAt?: string;
  updatedAt?: string;
  userId?: string;
  userName?: string;
  
  // Properties needed by other components in the application
  textSnippet: string;
  category: string;
  creator: 'USER' | 'AI' | 'AUTO';
  timestamp: number;
  comment?: string;
  isAutoGenerated?: boolean;
  importance?: number; // 1-5 scale for importance ranking
  flagged?: boolean;
}

export interface AnnotationOverlayProps {
  annotations: Annotation[];
  scale: number;
  onAnnotationClick?: (annotation: Annotation) => void;
  currentPage: number;
}

// Update the CATEGORY_COLORS to include background and text-highlight colors
const CATEGORY_COLORS: Record<string, { bg: string, highlight: string, border: string, text: string }> = {
  "Clause": {
    bg: "bg-blue-100",
    highlight: "bg-blue-200/60",
    border: "border-blue-200",
    text: "text-blue-800"
  },
  "Risk": {
    bg: "bg-red-100",
    highlight: "bg-red-200/60",
    border: "border-red-200",
    text: "text-red-800"
  },
  "Definition": {
    bg: "bg-green-100",
    highlight: "bg-green-200/60",
    border: "border-green-200",
    text: "text-green-800"
  },
  "Reference": {
    bg: "bg-purple-100",
    highlight: "bg-purple-200/60",
    border: "border-purple-200",
    text: "text-purple-800"
  },
  "Other": {
    bg: "bg-gray-100",
    highlight: "bg-gray-200/60",
    border: "border-gray-200",
    text: "text-gray-800"
  },
  // Default fallback
  "default": {
    bg: "bg-gray-100",
    highlight: "bg-gray-200/60",
    border: "border-gray-200",
    text: "text-gray-800"
  },
  // Auto-generated annotation colors
  "key_insight": {
    bg: "bg-amber-100",
    highlight: "bg-amber-200/60",
    border: "border-amber-200",
    text: "text-amber-800"
  },
  "definition": {
    bg: "bg-emerald-100",
    highlight: "bg-emerald-200/60",
    border: "border-emerald-200",
    text: "text-emerald-800"
  },
  "reference": {
    bg: "bg-indigo-100",
    highlight: "bg-indigo-200/60",
    border: "border-indigo-200",
    text: "text-indigo-800"
  },
  // User annotation type colors
  "highlight": {
    bg: "bg-yellow-100",
    highlight: "bg-yellow-200/60",
    border: "border-yellow-200",
    text: "text-yellow-800"
  },
  "note": {
    bg: "bg-blue-100",
    highlight: "bg-blue-200/60",
    border: "border-blue-200",
    text: "text-blue-800"
  },
  "draw": {
    bg: "bg-pink-100",
    highlight: "bg-pink-200/60",
    border: "border-pink-200",
    text: "text-pink-800"
  },
  "comment": {
    bg: "bg-cyan-100",
    highlight: "bg-cyan-200/60",
    border: "border-cyan-200",
    text: "text-cyan-800"
  }
};

// Enhanced function to get icon for annotation type
const getAnnotationIcon = (annotation: Annotation) => {
  if (annotation.isAutoGenerated) {
    switch (annotation.type) {
      case AnnotationType.KEY_INSIGHT:
        return <Lightbulb className="h-3 w-3 text-amber-600" />;
      case AnnotationType.DEFINITION:
        return <BookMarked className="h-3 w-3 text-emerald-600" />;
      case AnnotationType.REFERENCE:
        return <ExternalLink className="h-3 w-3 text-indigo-600" />;
      case AnnotationType.METHOD:
        return <FileText className="h-3 w-3 text-blue-600" />;
      case AnnotationType.RESULT:
        return <FileText className="h-3 w-3 text-green-600" />;
      case AnnotationType.GOAL:
        return <FileText className="h-3 w-3 text-amber-600" />;
      default:
        return <Lightbulb className="h-3 w-3 text-violet-600" />;
    }
  } else {
    switch (annotation.type) {
      case AnnotationType.NOTE:
        return <MessageSquare className="h-3 w-3 text-blue-600" />;
      case AnnotationType.HIGHLIGHT:
        return <Highlighter className="h-3 w-3 text-yellow-600" />;
      case AnnotationType.DRAW:
        return <PenTool className="h-3 w-3 text-pink-600" />;
      case AnnotationType.COMMENT:
        return <FileText className="h-3 w-3 text-cyan-600" />;
      default:
        return <Highlighter className="h-3 w-3 text-gray-600" />;
    }
  }
};

// Fix the getAnnotationColor function to return a string instead of an object
const getAnnotationColor = (annotation: Annotation): string => {
  const baseColors = {
    highlight: '#FFEB3B',   // Yellow
    note: '#4CAF50',        // Green
    comment: '#2196F3',     // Blue
    extract: '#9C27B0',     // Purple
    underline: '#FF9800',   // Orange
    strikethrough: '#F44336', // Red
    default: '#E0E0E0',     // Grey
  };

  // Return the appropriate color based on annotation type
  switch (annotation.type) {
    case 'highlight':
      return baseColors.highlight;
    case 'note':
      return baseColors.note;
    case 'comment':
      return baseColors.comment;
    case 'extract':
      return baseColors.extract;
    case 'underline':
      return baseColors.underline;
    case 'strikethrough':
      return baseColors.strikethrough;
    default:
      return baseColors.default;
  }
};

// Add the isSkimmingHighlight function definition
const isSkimmingHighlight = (annotation: Annotation): boolean => {
  // Check if the annotation is auto-generated (AI-suggested highlight from skimming)
  return annotation.isAutoGenerated === true;
};

// Fix the getBorderColor function to use string instead of object
const getBorderColor = (annotation: Annotation, baseColor: string): string => {
  // For skimming highlights, make the border more prominent
  if (isSkimmingHighlight(annotation)) {
    // Return a slightly darker shade of the base color
    return baseColor; // In a real app, you might use a color function to darken
  }
  return baseColor;
};

export function AnnotationOverlay({ 
  annotations, 
  scale, 
  onAnnotationClick,
  currentPage 
}: AnnotationOverlayProps) {
  const { state, dispatch } = useAnnotations();
  const [activeAnnotationId, setActiveAnnotationId] = useState<string | null>(null);
  const pageContainerRef = useRef<HTMLDivElement | null>(null);
  const tooltipTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const tooltipRef = useRef<HTMLDivElement>(null);
  const overlayRef = useRef<HTMLDivElement>(null);
  const activeAnnotationRef = useRef<HTMLDivElement>(null);
  
  // Get annotations for this page
  const pageAnnotations = annotations.filter(ann => ann.pageNumber === currentPage);
  
  // Track if the user wants to show margin flags (from app state)
  const showMarginFlags = true; // In a real app, this would come from settings
  
  // Use the current opacity setting (from app state)
  const highlightOpacity = 60; // In a real app, this would come from settings
  
  // Get custom styles for Allen AI BoundingBox
  const getAnnotationStyle = (annotation: Annotation, isActive: boolean) => {
    // Calculate opacity based on whether the annotation should be shown
    const opacity = shouldShowAnnotation(annotation) ? 
      (annotation.isAutoGenerated ? 0.4 : 0.6) : 0.1;
    
    // Get base color based on annotation type
    const colorStyle = getAnnotationColor(annotation);
    
    // Define base classes
    let baseClassName = "pdf-annotation"; 
    if (isActive) baseClassName += " pdf-annotation--active";
    
    // Define style object for the BoundingBox
    const style: React.CSSProperties = {
      backgroundColor: colorStyle,
      opacity: opacity,
      cursor: 'pointer',
      transition: 'opacity 0.15s ease, box-shadow 0.15s ease',
    };
    
    // Add skimming highlight specific style
    if (isSkimmingHighlight(annotation)) {
      style.borderLeft = `4px solid ${getBorderColor(annotation, colorStyle)}`;
    } else {
      style.border = `1px solid ${colorStyle}`;
    }
    
    // Add active style
    if (isActive) {
      style.opacity = 0.9;
      style.boxShadow = '0 0 0 2px rgba(59, 130, 246, 0.5)';
    }
    
    return { className: baseClassName, style };
  };

  useEffect(() => {
    // Find the page container using the nearest data attribute from PageWrapper
    if (!overlayRef.current) return;

    const pageElement = overlayRef.current.closest('[data-pdf-page]');
    if (pageElement) {
      pageContainerRef.current = pageElement as HTMLDivElement;
    } else {
      console.warn('Could not locate page container');
    }
  }, [currentPage]);
  
  // Sync activeAnnotationId with selectedAnnotation from context
  useEffect(() => {
    if (state.selectedAnnotationId) {
      setActiveAnnotationId(state.selectedAnnotationId);
    }
  }, [state.selectedAnnotationId]);
  
  // Handle click outside to deselect annotation
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        overlayRef.current && 
        !overlayRef.current.contains(event.target as Node) && 
        tooltipRef.current && 
        !tooltipRef.current.contains(event.target as Node)
      ) {
        setActiveAnnotationId(null);
        
        // Deselect in global state as well
        if (state.selectedAnnotationId) {
          dispatch({ type: 'SELECT_ANNOTATION', id: null });
        }
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [dispatch, state.selectedAnnotationId]);
  
  const handleAnnotationClick = (annotation: Annotation) => {
    // Toggle active state
    const newActiveId = activeAnnotationId === annotation.id ? null : annotation.id;
    setActiveAnnotationId(newActiveId);
    
    // Update global state
    dispatch({ type: 'SELECT_ANNOTATION', id: newActiveId });
    
    // Call external handler if provided
    if (onAnnotationClick) {
      onAnnotationClick(annotation);
    }
  };
  
  // Add tooltip position calculation functions
  const calculateTooltipPosition = (boundingRect: DOMRect) => {
    return {
      top: boundingRect.bottom + window.scrollY,
      left: boundingRect.left + boundingRect.width / 2 + window.scrollX
    };
  };
  
  // Add function to handle annotation mouse enter
  const handleAnnotationMouseEnter = (annotationId: string) => {
    setActiveAnnotationId(annotationId);
  };
  
  // Add function to handle annotation mouse leave
  const handleAnnotationMouseLeave = () => {
    // Only clear if it's not the active annotation
    if (!state.selectedAnnotationId) {
      setActiveAnnotationId(null);
    }
  };
  
  // Get the active annotation object
  const activeAnnotation = activeAnnotationId 
    ? pageAnnotations.find(a => a.id === activeAnnotationId) 
    : null;
  
  const getAnnotationTypeLabel = (annotation: Annotation) => {
    if (annotation.isAutoGenerated) {
      switch (annotation.type) {
        case AnnotationType.KEY_INSIGHT:
          return "Key Insight";
        case AnnotationType.DEFINITION:
          return "Definition";
        case AnnotationType.REFERENCE:
          return "Reference";
        case AnnotationType.METHOD:
          return "Method";
        case AnnotationType.RESULT:
          return "Result";
        case AnnotationType.GOAL:
          return "Goal";
        default:
          return annotation.category;
      }
    } else {
      switch (annotation.type) {
        case AnnotationType.HIGHLIGHT:
          return "Highlight";
        case AnnotationType.NOTE:
          return "Note";
        case AnnotationType.DRAW:
          return "Drawing";
        case AnnotationType.COMMENT:
          return "Comment";
        default:
          return annotation.category;
      }
    }
  };
  
  if (!pageContainerRef.current || pageAnnotations.length === 0) {
    return null;
  }
  
  // Check if we should show this annotation based on filters
  const shouldShowAnnotation = (annotation: Annotation) => {
    // Remove filter for auto-generated highlights if not present in filters
    // Remove filter by category if categories are not present in filters
    return true;
  };
  
  // Helper to determine if an annotation is a skimming highlight
  const isSkimmingHighlight = (annotation: Annotation) => {
    return annotation.isAutoGenerated && [
      AnnotationType.METHOD,
      AnnotationType.RESULT, 
      AnnotationType.GOAL,
      AnnotationType.KEY_INSIGHT,
      AnnotationType.DEFINITION,
      AnnotationType.REFERENCE
    ].includes(annotation.type as AnnotationType);
  };

  // Render annotations using Allen AI's BoundingBox
  const renderAnnotation = (annotation: Annotation, isActive: boolean) => {
    const { x, y, width, height } = annotation.boundingRect;
    const { className, style } = getAnnotationStyle(annotation, isActive);
    
    // We need to handle the fact that BoundingBox doesn't accept a style prop directly
    const customClassName = `${className} annotation-${annotation.id}`;
    
    // Add a style tag for this specific annotation's custom styling
    // This is a workaround since BoundingBox doesn't accept style directly
    useEffect(() => {
      // Create or update the style element for this annotation
      let styleElement = document.getElementById(`style-${annotation.id}`);
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = `style-${annotation.id}`;
        document.head.appendChild(styleElement);
      }
      
      // Create CSS rules from the style object
      const cssRules = Object.entries(style).map(([key, value]) => {
        // Convert camelCase to kebab-case
        const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
        return `${cssKey}: ${value};`;
      }).join(' ');
      
      // Apply the styles to the specific annotation class
      styleElement.textContent = `.annotation-${annotation.id} { ${cssRules} }`;
      
      // Clean up function
      return () => {
        if (styleElement) {
          document.head.removeChild(styleElement);
        }
      };
    }, [annotation.id, isActive]);
    
    // Since BoundingBox doesn't support onMouseEnter and onMouseLeave,
    // add event listeners programmatically after the component is rendered
    useEffect(() => {
      // Wait for the element to be rendered
      setTimeout(() => {
        const element = document.getElementById(annotation.id);
        if (element) {
          // Add mouse enter handler
          element.addEventListener('mouseenter', () => {
            handleAnnotationMouseEnter(annotation.id);
          });
          
          // Add mouse leave handler
          element.addEventListener('mouseleave', handleAnnotationMouseLeave);
          
          // Clean up
          return () => {
            element.removeEventListener('mouseenter', () => {
              handleAnnotationMouseEnter(annotation.id);
            });
            element.removeEventListener('mouseleave', handleAnnotationMouseLeave);
          };
        }
      }, 0);
    }, [annotation.id]);
    
    return (
      <AllenBoundingBox
        key={annotation.id}
        id={annotation.id}
        page={currentPage}
        top={y}
        left={x}
        width={width}
        height={height}
        isHighlighted={isActive}
        className={customClassName}
        onClick={() => handleAnnotationClick(annotation)}
        voiceOverLabel={`Annotation: ${annotation.textSnippet}`}
      />
    );
  };
  
  // Calculate tooltip position using the active annotation's position
  const [tooltipPosition, setTooltipPosition] = useState<{ top: number, left: number } | null>(null);
  
  // Update tooltip position when active annotation changes
  useEffect(() => {
    if (activeAnnotationId) {
      const annotationElement = document.getElementById(activeAnnotationId);
      if (annotationElement) {
        const rect = annotationElement.getBoundingClientRect();
        setTooltipPosition(calculateTooltipPosition(rect));
      }
    } else {
      setTooltipPosition(null);
    }
  }, [activeAnnotationId]);

  return (
    <div ref={overlayRef} className="pdf-annotations-overlay absolute inset-0">
      <AllenOverlay>
        {pageAnnotations.filter(shouldShowAnnotation).map(annotation => {
          const isActive = activeAnnotationId === annotation.id;
          return renderAnnotation(annotation, isActive);
        })}
      </AllenOverlay>

      {/* Tooltip for active annotation - keep outside of AllenOverlay */}
      {activeAnnotationId && activeAnnotation && tooltipPosition && (
        <div 
          ref={tooltipRef}
          className="pdf-annotation-tooltip absolute z-10 bg-popover shadow-md rounded-md p-2 pointer-events-auto" 
          style={{
            top: tooltipPosition.top + 'px',
            left: tooltipPosition.left + 'px',
            maxWidth: '300px',
            transform: 'translateX(-50%)'
          }}
        >
          <div className="flex items-start gap-1">
            <div className="mr-1 mt-0.5">
              {getAnnotationIcon(activeAnnotation)}
            </div>
            <div className="flex-1 min-w-0">
              <div className="font-medium text-xs mb-1 flex items-center gap-1">
                {getAnnotationTypeLabel(activeAnnotation)}
                {activeAnnotation.importance && (
                  <div className="text-amber-500 flex">
                    {Array.from({length: activeAnnotation.importance}).map((_, i) => (
                      <span key={i} className="text-xs">★</span>
                    ))}
                  </div>
                )}
              </div>
              <p className="text-xs text-muted-foreground">{activeAnnotation.textSnippet}</p>
              {activeAnnotation.comment && (
                <p className="text-xs mt-1 bg-muted/50 p-1 rounded">
                  {activeAnnotation.comment}
                </p>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
